#LAB4死锁
           --by吴云柯（14353320） using markdown


## 死锁出现的截图
* 跑了两次分别停在第957和729次
![](http://i1.piimg.com/567571/703224e486d6fcfa.png)


## 产生死锁的四个必要条件
* 互斥使用（资源独占） 
              一个资源每次只能给一个进程使用
* 不可强占（不可剥夺） 
资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放 
* 请求和保持（部分分配，占有申请） 
一个进程在申请新的资源的同时保持对原有资源的占有（只有这样才是动态申请，动态分配） 
* 循环等待 
存在一个进程等待队列 
{P1 , P2 , … , Pn}, 
其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路


##产生死锁的解释
创建一个新线程t，给t设置一个创建延时后执行a这个类的方法函数，这个方法函数调用b的last函数。
在第二个线程中，执行b这个类的方法函数，这个方法函数调用a的last函数。
因为在一个类中只能有一个线程在执行操作，因而，当有两个线程想要调用一个类里的操作时就发生了死锁。即：A占用了A的methodA函数，想要B的last（）资源，而与此同时，B占用了B的methodB函数想要A的last（）资源。满足了占有且等待的条件。